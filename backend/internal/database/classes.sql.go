// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: classes.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const updateClass = `-- name: UpdateClass :one
UPDATE classes
SET code       = COALESCE($2, code),
    year       = COALESCE($3, year),
    semester   = COALESCE($4, semester),
    programme  = COALESCE($5, programme),
    au         = COALESCE($6, au),
    updated_at =
        CASE
            WHEN (COALESCE($2, code) <> code OR
                  COALESCE($3, year) <> year OR
                  COALESCE($4, semester) <> semester OR
                  COALESCE($5, programme) <> programme OR
                  COALESCE($6, au) <> au)
                THEN NOW()
            ELSE updated_at
            END
WHERE id = $1
RETURNING id, code, year, semester, programme, au, updated_at
`

type UpdateClassParams struct {
	ID        int64       `json:"id"`
	Code      pgtype.Text `json:"code"`
	Year      pgtype.Int4 `json:"year"`
	Semester  pgtype.Text `json:"semester"`
	Programme pgtype.Text `json:"programme"`
	Au        pgtype.Int2 `json:"au"`
}

type UpdateClassRow struct {
	ID        int64              `json:"id"`
	Code      string             `json:"code"`
	Year      int32              `json:"year"`
	Semester  string             `json:"semester"`
	Programme string             `json:"programme"`
	Au        int16              `json:"au"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateClass(ctx context.Context, arg UpdateClassParams) (UpdateClassRow, error) {
	row := q.db.QueryRow(ctx, updateClass,
		arg.ID,
		arg.Code,
		arg.Year,
		arg.Semester,
		arg.Programme,
		arg.Au,
	)
	var i UpdateClassRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Year,
		&i.Semester,
		&i.Programme,
		&i.Au,
		&i.UpdatedAt,
	)
	return i, err
}
